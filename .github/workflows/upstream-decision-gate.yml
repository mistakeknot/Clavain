name: Upstream Decision Gate

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
      - labeled
      - edited

permissions:
  contents: read
  pull-requests: write

jobs:
  decision-gate:
    if: contains(join(github.event.pull_request.labels.*.name, ','), 'upstream-sync') || startsWith(github.event.pull_request.head.ref, 'automated/upstream-sync')
    runs-on: ubuntu-latest

    steps:
      - name: Validate decision record
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- clavain-upstream-decision-gate -->';
            const pr = context.payload.pull_request;
            const decisionPath = `docs/upstream-decisions/pr-${pr.number}.md`;
            const issues = [];

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100,
            });

            const touched = files.some((f) => f.filename === decisionPath);
            let recordBody = '';

            if (!touched) {
              issues.push(`Missing required decision record file \`${decisionPath}\` in this PR.`);
            } else {
              try {
                const contentResp = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: decisionPath,
                  ref: pr.head.sha,
                });

                if (Array.isArray(contentResp.data)) {
                  issues.push(`\`${decisionPath}\` must be a file, not a directory.`);
                } else {
                  recordBody = Buffer.from(contentResp.data.content, 'base64').toString('utf8');
                }
              } catch (err) {
                issues.push(`Could not read \`${decisionPath}\` from PR head: ${err.message}`);
              }
            }

            if (recordBody) {
              if (!/^Gate:\s*approved\s*$/mi.test(recordBody)) {
                issues.push('Decision record must include `Gate: approved` when ready to merge.');
              }
              if (/\bTBD\b/.test(recordBody)) {
                issues.push('Decision record still contains `TBD` placeholders. Replace with explicit decisions.');
              }
            }

            const pass = issues.length === 0;
            const bodyLines = [
              marker,
              '## Upstream Decision Gate',
              '',
              pass
                ? '✅ Decision record present and approved.'
                : '❌ Decision record requirements are not met.',
              '',
              `Expected decision file: \`${decisionPath}\``,
            ];

            if (!pass) {
              bodyLines.push('', '### Required Fixes');
              for (const item of issues) {
                bodyLines.push(`- ${item}`);
              }
              bodyLines.push('', 'Template: `docs/templates/upstream-decision-record.md`');
            }

            bodyLines.push('', '_This comment is managed by `.github/workflows/upstream-decision-gate.yml`._');
            const body = bodyLines.join('\n');

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              per_page: 100,
            });

            const existing = comments.find((c) => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body,
              });
            }

            if (!pass) {
              core.setFailed(issues.join('\n'));
            }
